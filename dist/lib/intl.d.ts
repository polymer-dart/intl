import { OperatorMethods, double } from "@dart2ts/dart/utils";
import * as core from "@dart2ts/dart/core";
import * as lib6 from "./number_symbols";
import * as lib10 from "./date_symbols";
export declare var toBeginningOfSentenceCase: (input: string, locale?: string) => string;
export declare var _upperCaseLetter: (input: string, locale: string) => string;
export declare var _dayOfYear: (month: number, day: number, leapYear: boolean) => number;
export declare var _isLeapYear: (date: core.DartDateTime) => boolean;
export declare var ordinalDayFromMarchFirst: (month: number, day: number) => number;
export declare var _iterable: (s: string) => core.DartIterable<any>;
export declare var _iterator: (s: string) => _StringIterator;
export declare class Intl {
    _locale: string;
    static defaultLocale: string;
    private static __$_defaultLocale;
    static _defaultLocale: string;
    private static __$systemLocale;
    static systemLocale: string;
    date(pattern?: string, desiredLocale?: string): DateFormat;
    constructor(aLocale?: string);
    Intl(aLocale?: string): void;
    static message(message_str: string, _namedArguments?: {
        desc?: string;
        examples?: core.DartMap<string, any>;
        locale?: string;
        name?: string;
        args?: core.DartList<any>;
        meaning?: string;
        skip?: boolean;
    }): string;
    static _message(message_str: string, locale: string, name: string, args: core.DartList<any>, meaning: string): string;
    readonly locale: string;
    static verifiedLocale(newLocale: string, localeExists: Function, _namedArguments?: {
        onFailure?: Function;
    }): string;
    static _throwLocaleError(localeName: string): string;
    static shortLocale(aLocale: string): string;
    static canonicalizedLocale(aLocale: string): string;
    static plural(howMany: number, _namedArguments?: {
        zero?: string;
        one?: string;
        two?: string;
        few?: string;
        many?: string;
        other?: string;
        desc?: string;
        examples?: core.DartMap<string, any>;
        locale?: string;
        name?: string;
        args?: core.DartList<any>;
        meaning?: string;
        skip?: boolean;
    }): string;
    static _plural(howMany: number, _namedArguments?: {
        zero?: string;
        one?: string;
        two?: string;
        few?: string;
        many?: string;
        other?: string;
        locale?: string;
        name?: string;
        args?: core.DartList<any>;
        meaning?: string;
    }): string;
    static pluralLogic(howMany: number, _namedArguments?: {
        zero?: any;
        one?: any;
        two?: any;
        few?: any;
        many?: any;
        other?: any;
        locale?: string;
        meaning?: string;
    }): any;
    private static __$_cachedPluralRule;
    static _cachedPluralRule: any;
    private static __$_cachedPluralLocale;
    static _cachedPluralLocale: string;
    static _pluralRule(locale: string, howMany: number): any;
    static gender(targetGender: string, _namedArguments?: {
        female?: string;
        male?: string;
        other?: string;
        desc?: string;
        examples?: core.DartMap<string, any>;
        locale?: string;
        name?: string;
        args?: core.DartList<any>;
        meaning?: string;
        skip?: boolean;
    }): string;
    static _gender(targetGender: string, _namedArguments?: {
        female?: string;
        male?: string;
        other?: string;
        desc?: string;
        examples?: core.DartMap<string, any>;
        locale?: string;
        name?: string;
        args?: core.DartList<any>;
        meaning?: string;
    }): string;
    static genderLogic(targetGender: string, _namedArguments?: {
        female?: any;
        male?: any;
        other?: any;
        locale?: string;
    }): any;
    static select(choice: any, cases: core.DartMap<string, string>, _namedArguments?: {
        desc?: string;
        examples?: core.DartMap<string, any>;
        locale?: string;
        name?: string;
        args?: core.DartList<any>;
        meaning?: string;
        skip?: boolean;
    }): string;
    static _select(choice: any, cases: core.DartMap<string, string>, _namedArguments?: {
        locale?: string;
        name?: string;
        args?: core.DartList<any>;
        meaning?: string;
    }): string;
    static selectLogic(choice: any, cases: core.DartMap<string, any>): any;
    static withLocale(locale: string, _function: () => any): any;
    static getCurrentLocale(): string;
    toString(): string;
}
export declare class BidiFormatter {
    contextDirection: TextDirection;
    _alwaysSpan: boolean;
    LTR(alwaysSpan?: any): void;
    static LTR: new (alwaysSpan: any) => BidiFormatter;
    RTL(alwaysSpan?: any): void;
    static RTL: new (alwaysSpan: any) => BidiFormatter;
    UNKNOWN(alwaysSpan?: any): void;
    static UNKNOWN: new (alwaysSpan: any) => BidiFormatter;
    readonly isRTL: boolean;
    wrapWithSpan(text: string, _namedArguments?: {
        isHtml?: boolean;
        resetDir?: boolean;
        direction?: TextDirection;
    }): string;
    wrapWithUnicode(text: string, _namedArguments?: {
        isHtml?: boolean;
        resetDir?: boolean;
        direction?: TextDirection;
    }): string;
    estimateDirection(text: string, _namedArguments?: {
        isHtml?: boolean;
    }): TextDirection;
    _resetDir(text: string, direction: TextDirection, isHtml: boolean): string;
}
export declare class TextDirection {
    private static __$LTR;
    static readonly LTR: any;
    private static __$RTL;
    static readonly RTL: any;
    private static __$UNKNOWN;
    static readonly UNKNOWN: any;
    value: string;
    spanText: string;
    _(value: string, spanText: string): void;
    static _: new (value: string, spanText: string) => TextDirection;
    isDirectionChange(otherDirection: TextDirection): boolean;
}
export declare class Bidi {
    private static __$LRE;
    static readonly LRE: any;
    private static __$RLE;
    static readonly RLE: any;
    private static __$PDF;
    static readonly PDF: any;
    private static __$LRM;
    static readonly LRM: any;
    private static __$RLM;
    static readonly RLM: any;
    private static __$_RTL_DETECTION_THRESHOLD;
    static _RTL_DETECTION_THRESHOLD: number;
    private static __$_LTR_CHARS;
    static readonly _LTR_CHARS: string;
    private static __$_RTL_CHARS;
    static readonly _RTL_CHARS: string;
    static stripHtmlIfNeeded(text: string): string;
    static startsWithLtr(text: string, isHtml?: any): boolean;
    static startsWithRtl(text: string, isHtml?: any): boolean;
    static endsWithLtr(text: string, isHtml?: any): boolean;
    static endsWithRtl(text: string, isHtml?: any): boolean;
    static hasAnyLtr(text: string, isHtml?: any): boolean;
    static hasAnyRtl(text: string, isHtml?: any): boolean;
    private static __$_rtlLocaleRegex;
    static _rtlLocaleRegex: any;
    private static __$_lastLocaleCheckedForRtl;
    static _lastLocaleCheckedForRtl: string;
    private static __$_lastRtlCheck;
    static _lastRtlCheck: boolean;
    static isRtlLanguage(languageString?: string): boolean;
    static enforceRtlInHtml(html: string): string;
    static enforceRtlInText(text: string): string;
    static enforceLtrInHtml(html: string): string;
    static enforceLtrInText(text: string): string;
    static _enforceInHtmlHelper(html: string, direction: string): string;
    static guardBracketInHtml(str: string, isRtlContext?: boolean): string;
    static guardBracketInText(str: string, isRtlContext?: boolean): string;
    static _guardBracketHelper(str: string, regexp: core.DartRegExp, before?: string, after?: string): string;
    static estimateDirectionOfText(text: string, _namedArguments?: {
        isHtml?: boolean;
    }): TextDirection;
    static normalizeHebrewQuote(str: string): string;
    static detectRtlDirectionality(str: string, _namedArguments?: {
        isHtml?: boolean;
    }): boolean;
    constructor();
    Bidi(): void;
}
export declare class _CompactStyleBase {
    styleForSign(number: any): _CompactStyle;
    readonly totalDigits: number;
    readonly divisor: number;
    readonly allStyles: core.DartIterable<_CompactStyle>;
    constructor();
    _CompactStyleBase(): void;
}
export declare enum _CompactFormatType {
    COMPACT_DECIMAL_SHORT_PATTERN = 0,
    COMPACT_DECIMAL_LONG_PATTERN = 1,
    COMPACT_DECIMAL_SHORT_CURRENCY_PATTERN = 2
}
export declare class DateFormat {
    constructor(newPattern?: string, locale?: string);
    DateFormat(newPattern?: string, locale?: string): void;
    format(date: core.DartDateTime): string;
    formatDuration(reference: core.DartDateTime): string;
    formatDurationFrom(duration: core.DartDuration, date: core.DartDateTime): string;
    parse(inputString: string, utc?: any): core.DartDateTime;
    parseLoose(inputString: string, utc?: any): core.DartDateTime;
    _parseLoose(inputString: string, utc: boolean): core.DartDateTime;
    parseStrict(inputString: string, utc?: any): core.DartDateTime;
    _parse(inputString: string, _namedArguments?: {
        utc?: any;
        strict?: any;
    }): core.DartDateTime;
    readonly dateOnly: boolean;
    _dateOnly: boolean;
    readonly _checkDateOnly: boolean;
    parseUTC(inputString: string): core.DartDateTime;
    parseUtc(inputString: string): core.DartDateTime;
    readonly locale: string;
    static allLocalesWithSymbols(): core.DartList<string>;
    d(locale?: any): void;
    static d: new (locale: any) => DateFormat;
    E(locale?: any): void;
    static E: new (locale: any) => DateFormat;
    EEEE(locale?: any): void;
    static EEEE: new (locale: any) => DateFormat;
    LLL(locale?: any): void;
    static LLL: new (locale: any) => DateFormat;
    LLLL(locale?: any): void;
    static LLLL: new (locale: any) => DateFormat;
    M(locale?: any): void;
    static M: new (locale: any) => DateFormat;
    Md(locale?: any): void;
    static Md: new (locale: any) => DateFormat;
    MEd(locale?: any): void;
    static MEd: new (locale: any) => DateFormat;
    MMM(locale?: any): void;
    static MMM: new (locale: any) => DateFormat;
    MMMd(locale?: any): void;
    static MMMd: new (locale: any) => DateFormat;
    MMMEd(locale?: any): void;
    static MMMEd: new (locale: any) => DateFormat;
    MMMM(locale?: any): void;
    static MMMM: new (locale: any) => DateFormat;
    MMMMd(locale?: any): void;
    static MMMMd: new (locale: any) => DateFormat;
    MMMMEEEEd(locale?: any): void;
    static MMMMEEEEd: new (locale: any) => DateFormat;
    QQQ(locale?: any): void;
    static QQQ: new (locale: any) => DateFormat;
    QQQQ(locale?: any): void;
    static QQQQ: new (locale: any) => DateFormat;
    y(locale?: any): void;
    static y: new (locale: any) => DateFormat;
    yM(locale?: any): void;
    static yM: new (locale: any) => DateFormat;
    yMd(locale?: any): void;
    static yMd: new (locale: any) => DateFormat;
    yMEd(locale?: any): void;
    static yMEd: new (locale: any) => DateFormat;
    yMMM(locale?: any): void;
    static yMMM: new (locale: any) => DateFormat;
    yMMMd(locale?: any): void;
    static yMMMd: new (locale: any) => DateFormat;
    yMMMEd(locale?: any): void;
    static yMMMEd: new (locale: any) => DateFormat;
    yMMMM(locale?: any): void;
    static yMMMM: new (locale: any) => DateFormat;
    yMMMMd(locale?: any): void;
    static yMMMMd: new (locale: any) => DateFormat;
    yMMMMEEEEd(locale?: any): void;
    static yMMMMEEEEd: new (locale: any) => DateFormat;
    yQQQ(locale?: any): void;
    static yQQQ: new (locale: any) => DateFormat;
    yQQQQ(locale?: any): void;
    static yQQQQ: new (locale: any) => DateFormat;
    H(locale?: any): void;
    static H: new (locale: any) => DateFormat;
    Hm(locale?: any): void;
    static Hm: new (locale: any) => DateFormat;
    Hms(locale?: any): void;
    static Hms: new (locale: any) => DateFormat;
    j(locale?: any): void;
    static j: new (locale: any) => DateFormat;
    jm(locale?: any): void;
    static jm: new (locale: any) => DateFormat;
    jms(locale?: any): void;
    static jms: new (locale: any) => DateFormat;
    jmv(locale?: any): void;
    static jmv: new (locale: any) => DateFormat;
    jmz(locale?: any): void;
    static jmz: new (locale: any) => DateFormat;
    jv(locale?: any): void;
    static jv: new (locale: any) => DateFormat;
    jz(locale?: any): void;
    static jz: new (locale: any) => DateFormat;
    m(locale?: any): void;
    static m: new (locale: any) => DateFormat;
    ms(locale?: any): void;
    static ms: new (locale: any) => DateFormat;
    s(locale?: any): void;
    static s: new (locale: any) => DateFormat;
    add_d(): DateFormat;
    add_E(): DateFormat;
    add_EEEE(): DateFormat;
    add_LLL(): DateFormat;
    add_LLLL(): DateFormat;
    add_M(): DateFormat;
    add_Md(): DateFormat;
    add_MEd(): DateFormat;
    add_MMM(): DateFormat;
    add_MMMd(): DateFormat;
    add_MMMEd(): DateFormat;
    add_MMMM(): DateFormat;
    add_MMMMd(): DateFormat;
    add_MMMMEEEEd(): DateFormat;
    add_QQQ(): DateFormat;
    add_QQQQ(): DateFormat;
    add_y(): DateFormat;
    add_yM(): DateFormat;
    add_yMd(): DateFormat;
    add_yMEd(): DateFormat;
    add_yMMM(): DateFormat;
    add_yMMMd(): DateFormat;
    add_yMMMEd(): DateFormat;
    add_yMMMM(): DateFormat;
    add_yMMMMd(): DateFormat;
    add_yMMMMEEEEd(): DateFormat;
    add_yQQQ(): DateFormat;
    add_yQQQQ(): DateFormat;
    add_H(): DateFormat;
    add_Hm(): DateFormat;
    add_Hms(): DateFormat;
    add_j(): DateFormat;
    add_jm(): DateFormat;
    add_jms(): DateFormat;
    add_jmv(): DateFormat;
    add_jmz(): DateFormat;
    add_jv(): DateFormat;
    add_jz(): DateFormat;
    add_m(): DateFormat;
    add_ms(): DateFormat;
    add_s(): DateFormat;
    private static __$ABBR_MONTH;
    static readonly ABBR_MONTH: string;
    private static __$DAY;
    static readonly DAY: string;
    private static __$ABBR_WEEKDAY;
    static readonly ABBR_WEEKDAY: string;
    private static __$WEEKDAY;
    static readonly WEEKDAY: string;
    private static __$ABBR_STANDALONE_MONTH;
    static readonly ABBR_STANDALONE_MONTH: string;
    private static __$STANDALONE_MONTH;
    static readonly STANDALONE_MONTH: string;
    private static __$NUM_MONTH;
    static readonly NUM_MONTH: string;
    private static __$NUM_MONTH_DAY;
    static readonly NUM_MONTH_DAY: string;
    private static __$NUM_MONTH_WEEKDAY_DAY;
    static readonly NUM_MONTH_WEEKDAY_DAY: string;
    private static __$ABBR_MONTH_DAY;
    static readonly ABBR_MONTH_DAY: string;
    private static __$ABBR_MONTH_WEEKDAY_DAY;
    static readonly ABBR_MONTH_WEEKDAY_DAY: string;
    private static __$MONTH;
    static readonly MONTH: string;
    private static __$MONTH_DAY;
    static readonly MONTH_DAY: string;
    private static __$MONTH_WEEKDAY_DAY;
    static readonly MONTH_WEEKDAY_DAY: string;
    private static __$ABBR_QUARTER;
    static readonly ABBR_QUARTER: string;
    private static __$QUARTER;
    static readonly QUARTER: string;
    private static __$YEAR;
    static readonly YEAR: string;
    private static __$YEAR_NUM_MONTH;
    static readonly YEAR_NUM_MONTH: string;
    private static __$YEAR_NUM_MONTH_DAY;
    static readonly YEAR_NUM_MONTH_DAY: string;
    private static __$YEAR_NUM_MONTH_WEEKDAY_DAY;
    static readonly YEAR_NUM_MONTH_WEEKDAY_DAY: string;
    private static __$YEAR_ABBR_MONTH;
    static readonly YEAR_ABBR_MONTH: string;
    private static __$YEAR_ABBR_MONTH_DAY;
    static readonly YEAR_ABBR_MONTH_DAY: string;
    private static __$YEAR_ABBR_MONTH_WEEKDAY_DAY;
    static readonly YEAR_ABBR_MONTH_WEEKDAY_DAY: string;
    private static __$YEAR_MONTH;
    static readonly YEAR_MONTH: string;
    private static __$YEAR_MONTH_DAY;
    static readonly YEAR_MONTH_DAY: string;
    private static __$YEAR_MONTH_WEEKDAY_DAY;
    static readonly YEAR_MONTH_WEEKDAY_DAY: string;
    private static __$YEAR_ABBR_QUARTER;
    static readonly YEAR_ABBR_QUARTER: string;
    private static __$YEAR_QUARTER;
    static readonly YEAR_QUARTER: string;
    private static __$HOUR24;
    static readonly HOUR24: string;
    private static __$HOUR24_MINUTE;
    static readonly HOUR24_MINUTE: string;
    private static __$HOUR24_MINUTE_SECOND;
    static readonly HOUR24_MINUTE_SECOND: string;
    private static __$HOUR;
    static readonly HOUR: string;
    private static __$HOUR_MINUTE;
    static readonly HOUR_MINUTE: string;
    private static __$HOUR_MINUTE_SECOND;
    static readonly HOUR_MINUTE_SECOND: string;
    private static __$HOUR_MINUTE_GENERIC_TZ;
    static readonly HOUR_MINUTE_GENERIC_TZ: string;
    private static __$HOUR_MINUTE_TZ;
    static readonly HOUR_MINUTE_TZ: string;
    private static __$HOUR_GENERIC_TZ;
    static readonly HOUR_GENERIC_TZ: string;
    private static __$HOUR_TZ;
    static readonly HOUR_TZ: string;
    private static __$MINUTE;
    static readonly MINUTE: string;
    private static __$MINUTE_SECOND;
    static readonly MINUTE_SECOND: string;
    private static __$SECOND;
    static readonly SECOND: string;
    _locale: string;
    _pattern: string;
    _formatFieldsPrivate: core.DartList<_DateFormatField>;
    readonly _formatFields: core.DartList<_DateFormatField>;
    _useDefaultPattern(): void;
    private static __$_matchers;
    static _matchers: core.DartList<core.DartRegExp>;
    _appendPattern(inputPattern: string, separator?: string): void;
    addPattern(inputPattern: string, separator?: string): DateFormat;
    readonly pattern: string;
    readonly _availableSkeletons: core.DartMap<any, any>;
    readonly dateSymbols: lib10.DateSymbols;
    private static __$_useNativeDigitsByDefault;
    static _useNativeDigitsByDefault: core.DartMap<string, boolean>;
    static shouldUseNativeDigitsByDefaultFor(locale: string): boolean;
    static useNativeDigitsByDefaultFor(locale: string, value: boolean): void;
    _useNativeDigits: boolean;
    useNativeDigits: boolean;
    private static __$_digitMatchers;
    static _digitMatchers: core.DartMap<string, core.DartRegExp>;
    _digitMatcher: core.DartRegExp;
    readonly digitMatcher: core.DartRegExp;
    private static __$_asciiDigitMatcher;
    static _asciiDigitMatcher: core.DartRegExp;
    _localeZeroCodeUnit: number;
    readonly localeZeroCodeUnit: number;
    private static __$_asciiZeroCodeUnit;
    static _asciiZeroCodeUnit: number;
    _localeZero: string;
    readonly localeZero: string;
    readonly usesNativeDigits: boolean;
    readonly usesAsciiDigits: boolean;
    _localizeDigits(numberString: string): string;
    _initDigitMatcher(): core.DartRegExp;
    static localeExists(localeName: any): boolean;
    static readonly _fieldConstructors: core.DartList<any>;
    parsePattern(pattern: string): core.DartList<_DateFormatField>;
    _parsePatternHelper(pattern: string): core.DartList<_DateFormatField>;
    _match(pattern: string): _DateFormatField;
}
export declare class _DateFormatField {
    pattern: string;
    parent: DateFormat;
    _trimmedPattern: string;
    constructor(pattern: string, parent: DateFormat);
    _DateFormatField(pattern: string, parent: DateFormat): void;
    readonly forDate: boolean;
    readonly width: number;
    fullPattern(): string;
    toString(): string;
    format(date: core.DartDateTime): string;
    parse(input: _Stream, dateFields: _DateBuilder): void;
    parseLoose(input: _Stream, dateFields: _DateBuilder): void;
    parseLiteral(input: _Stream): void;
    parseLiteralLoose(input: _Stream): void;
    _trimWhitespace(input: _Stream): void;
    throwFormatException(stream: _Stream): void;
}
export declare class _DateBuilder {
    year: number;
    month: number;
    day: number;
    hour: number;
    minute: number;
    second: number;
    fractionalSecond: number;
    pm: boolean;
    utc: boolean;
    _dateOnly: boolean;
    setYear(x: any): void;
    setMonth(x: any): void;
    setDay(x: any): void;
    setHour(x: any): void;
    setMinute(x: any): void;
    setSecond(x: any): void;
    setFractionalSecond(x: any): void;
    readonly hour24: number;
    verify(s: string): void;
    _verify(value: number, min: number, max: number, desc: string, originalInput: string, parsed?: core.DartDateTime): void;
    asDate(_namedArguments?: {
        retries?: number;
    }): core.DartDateTime;
    _correctForErrors(result: core.DartDateTime, retries: number): core.DartDateTime;
    constructor();
    _DateBuilder(): void;
}
export declare class _Stream {
    contents: any;
    index: number;
    constructor(contents: any);
    _Stream(contents: any): void;
    atEnd(): boolean;
    next(): any;
    read(howMany?: number): any;
    startsWith(pattern: string): boolean;
    peek(howMany?: number): any;
    rest(): any;
    findIndex(f: Function): number;
    findIndexes(f: Function): core.DartList<any>;
    nextInteger(_namedArguments?: {
        digitMatcher?: core.DartRegExp;
        zeroDigit?: number;
    }): number;
}
export declare class NumberFormat {
    _negativePrefix: string;
    _positivePrefix: string;
    _negativeSuffix: string;
    _positiveSuffix: string;
    _groupingSize: number;
    _finalGroupingSize: number;
    _groupingSizeSetExplicitly: boolean;
    _decimalSeparatorAlwaysShown: boolean;
    _useSignForPositiveExponent: boolean;
    _useExponentialNotation: boolean;
    _isForCurrency: boolean;
    maximumIntegerDigits: number;
    minimumIntegerDigits: number;
    maximumFractionDigits: number;
    minimumFractionDigits: number;
    minimumExponentDigits: number;
    _significantDigits: number;
    private static __$_ln10;
    static _ln10: any;
    significantDigits: number;
    significantDigitsInUse: boolean;
    _multiplier: number;
    _internalMultiplier: number;
    _multiplierDigits: number;
    _pattern: string;
    _locale: string;
    _symbols: lib6.NumberSymbols;
    currencyName: string;
    _currencySymbol: string;
    readonly currencySymbol: string;
    readonly decimalDigits: number;
    _decimalDigits: number;
    readonly _defaultDecimalDigits: number;
    readonly _overridesDecimalDigits: boolean;
    _buffer: core.DartStringBuffer;
    constructor(newPattern?: string, locale?: string);
    static $NumberFormat(newPattern?: string, locale?: string): NumberFormat;
    decimalPattern(locale?: string): void;
    static decimalPattern: new (locale: string) => NumberFormat;
    percentPattern(locale?: string): void;
    static percentPattern: new (locale: string) => NumberFormat;
    scientificPattern(locale?: string): void;
    static scientificPattern: new (locale: string) => NumberFormat;
    private static __$_checkCurrencyName;
    static _checkCurrencyName: any;
    static $currencyPattern(locale?: string, currencyNameOrSymbol?: string): NumberFormat;
    static currencyPattern: new (locale: string, currencyNameOrSymbol: string) => NumberFormat;
    currency(_namedArguments?: {
        locale?: string;
        name?: string;
        symbol?: string;
        decimalDigits?: number;
        customPattern?: string;
    }): void;
    static currency: new (_namedArguments?: {
        locale?: string;
        name?: string;
        symbol?: string;
        decimalDigits?: number;
        customPattern?: string;
    }) => NumberFormat;
    static $simpleCurrency(_namedArguments?: {
        locale?: string;
        name?: string;
        decimalDigits?: number;
    }): NumberFormat;
    static simpleCurrency: new (_namedArguments?: {
        locale?: string;
        name?: string;
        decimalDigits?: number;
    }) => NumberFormat;
    simpleCurrencySymbol(currencyCode: string): string;
    private static __$_simpleCurrencySymbols;
    static _simpleCurrencySymbols: core.DartMap<string, string>;
    _forPattern(locale: string, getPattern: (symbols: lib6.NumberSymbols) => string, _namedArguments?: {
        name?: string;
        currencySymbol?: string;
        computeCurrencySymbol?: (NumberFormat: any) => string;
        decimalDigits?: number;
        isForCurrency?: boolean;
    }): void;
    static _forPattern: new (locale: string, getPattern: (symbols: lib6.NumberSymbols) => string, _namedArguments?: {
        name?: string;
        currencySymbol?: string;
        computeCurrencySymbol?: (NumberFormat: any) => string;
        decimalDigits?: number;
        isForCurrency?: boolean;
    }) => NumberFormat;
    static $compact(_namedArguments?: {
        locale?: string;
    }): NumberFormat;
    static compact: new (_namedArguments?: {
        locale?: string;
    }) => NumberFormat;
    static $compactLong(_namedArguments?: {
        locale?: string;
    }): NumberFormat;
    static compactLong: new (_namedArguments?: {
        locale?: string;
    }) => NumberFormat;
    static $compactSimpleCurrency(_namedArguments?: {
        locale?: string;
        name?: string;
        decimalDigits?: number;
    }): NumberFormat;
    static compactSimpleCurrency: new (_namedArguments?: {
        locale?: string;
        name?: string;
        decimalDigits?: number;
    }) => NumberFormat;
    static $compactCurrency(_namedArguments?: {
        locale?: string;
        name?: string;
        symbol?: string;
        decimalDigits?: number;
    }): NumberFormat;
    static compactCurrency: new (_namedArguments?: {
        locale?: string;
        name?: string;
        symbol?: string;
        decimalDigits?: number;
    }) => NumberFormat;
    readonly locale: string;
    static localeExists(localeName: any): boolean;
    readonly symbols: lib6.NumberSymbols;
    format(number: any): string;
    parse(text: string): number;
    _formatNumber(number: any): void;
    _formatExponential(number: number): void;
    _formatExponent(exponent: number): void;
    private static __$_maxInt;
    static _maxInt: any;
    private static __$_maxDigits;
    static _maxDigits: any;
    _isInfinite(number: any): boolean;
    _isNaN(number: any): boolean;
    _floor(number: any): any;
    _round(number: any): any;
    static numberOfIntegerDigits(number: any): number;
    _fractionDigitsAfter(remainingSignificantDigits: number): number;
    _formatFixed(number: any): void;
    _integerDigits(integerPart: any, extraIntegerDigits: any): string;
    _mainIntegerDigits(integer: any): string;
    _formatFractionPart(fractionPart: string): void;
    _decimalSeparator(fractionPresent: boolean): void;
    _hasIntegerDigits(digits: string): boolean;
    _add(x: string): void;
    _addZero(): void;
    _addDigit(x: number): void;
    _pad(numberOfDigits: number, basic: string): void;
    _slowPad(numberOfDigits: number, basic: string): void;
    _group(totalLength: number, position: number): void;
    private static __$_zero;
    static readonly _zero: any;
    _localeZero: number;
    _zeroOffset: number;
    _signPrefix(x: any): string;
    _signSuffix(x: any): string;
    _setPattern(newPattern: string): void;
    turnOffGrouping(): void;
    toString(): string;
}
export declare class _NumberParser {
    format: NumberFormat;
    text: string;
    input: _Stream;
    value: number;
    readonly symbols: lib6.NumberSymbols;
    _normalized: core.DartStringBuffer;
    gotPositive: boolean;
    gotNegative: boolean;
    gotPositiveSuffix: boolean;
    gotNegativeSuffix: boolean;
    done: boolean;
    prefixesSkipped: boolean;
    scale: number;
    readonly _positivePrefix: string;
    readonly _negativePrefix: string;
    readonly _positiveSuffix: string;
    readonly _negativeSuffix: string;
    readonly _zero: number;
    readonly _localeZero: number;
    constructor(format: NumberFormat, text: any);
    _NumberParser(format: NumberFormat, text: any): void;
    readonly replacements: core.DartMap<string, Function>;
    _replacements: core.DartMap<string, Function>;
    _initializeReplacements(): core.DartMap<string, Function>;
    invalidFormat(): void;
    handleSpace(): void | "";
    readonly groupingIsNotASpaceOrElseItIsSpaceFollowedByADigit: boolean;
    asDigit(char: string): number;
    checkPrefixes(_namedArguments?: {
        skip?: boolean;
    }): void;
    checkSuffixes(): void;
    processNonDigit(): void;
    parse(): number;
    invalidNumber(): void;
    parseNumber(input: _Stream): number;
}
export declare class _NumberFormatParser {
    private static __$_PATTERN_SEPARATOR;
    static readonly _PATTERN_SEPARATOR: any;
    private static __$_QUOTE;
    static readonly _QUOTE: any;
    private static __$_PATTERN_DIGIT;
    static readonly _PATTERN_DIGIT: any;
    private static __$_PATTERN_ZERO_DIGIT;
    static readonly _PATTERN_ZERO_DIGIT: any;
    private static __$_PATTERN_GROUPING_SEPARATOR;
    static readonly _PATTERN_GROUPING_SEPARATOR: any;
    private static __$_PATTERN_DECIMAL_SEPARATOR;
    static readonly _PATTERN_DECIMAL_SEPARATOR: any;
    private static __$_PATTERN_CURRENCY_SIGN;
    static readonly _PATTERN_CURRENCY_SIGN: any;
    private static __$_PATTERN_PER_MILLE;
    static readonly _PATTERN_PER_MILLE: any;
    private static __$_PER_MILLE_SCALE;
    static readonly _PER_MILLE_SCALE: any;
    private static __$_PATTERN_PERCENT;
    static readonly _PATTERN_PERCENT: any;
    private static __$_PERCENT_SCALE;
    static readonly _PERCENT_SCALE: any;
    private static __$_PATTERN_EXPONENT;
    static readonly _PATTERN_EXPONENT: any;
    private static __$_PATTERN_PLUS;
    static readonly _PATTERN_PLUS: any;
    format: NumberFormat;
    pattern: _StringIterator;
    currencySymbol: string;
    decimalDigits: number;
    constructor(format: NumberFormat, input: any, currencySymbol: string, decimalDigits: number);
    _NumberFormatParser(format: NumberFormat, input: any, currencySymbol: string, decimalDigits: number): void;
    readonly symbols: lib6.NumberSymbols;
    parse(): void;
    inQuote: boolean;
    _parseAffix(): string;
    parseCharacterAffix(affix: core.DartStringBuffer): boolean;
    decimalPos: any;
    digitLeftCount: any;
    zeroDigitCount: any;
    digitRightCount: any;
    groupingCount: any;
    _parseTrunk(): string;
    parseTrunkCharacter(trunk: any): boolean;
}
export declare class _StringIterable extends core.DartIterableBase<string> {
    iterator: core.DartIterator<string>;
    constructor(s: string);
    _StringIterable(s: string): void;
}
export declare class _StringIterator implements core.DartIterator<string> {
    next(value?: any): IteratorResult<string>;
    input: string;
    nextIndex: number;
    _current: string;
    constructor(input: any);
    _StringIterator(input: any): void;
    readonly current: string;
    moveNext(): boolean;
    readonly peek: string;
    readonly iterator: core.DartIterator<string>;
    static _validate(input: any): string;
}
export declare class MicroMoney {
    constructor(micros: any);
    static $MicroMoney(micros: any): MicroMoney;
}
export declare class _MicroMoney implements MicroMoney {
    _micros: any;
    constructor(_micros: any);
    _MicroMoney(_micros: any): void;
    private static __$_multiplier;
    static readonly _multiplier: any;
    readonly _integerPart: any;
    readonly _fractionPart: number;
    readonly isNegative: boolean;
    abs(): _MicroMoney;
    [OperatorMethods.MINUS](other: any): _MicroMoney;
    [OperatorMethods.PLUS](other: any): _MicroMoney;
    [OperatorMethods.QUOTIENT](divisor: any): _MicroMoney;
    [OperatorMethods.MULTIPLY](other: any): _MicroMoney;
    remainder(other: any): _MicroMoney;
    toDouble(): double;
    toInt(): number;
    toString(): string;
}
export declare class _CompactStyleWithNegative extends _CompactStyleBase {
    constructor(positiveStyle: _CompactStyle, negativeStyle: _CompactStyle);
    _CompactStyleWithNegative(positiveStyle: _CompactStyle, negativeStyle: _CompactStyle): void;
    positiveStyle: _CompactStyle;
    negativeStyle: _CompactStyle;
    styleForSign(number: any): _CompactStyle;
    readonly totalDigits: number;
    readonly divisor: number;
    readonly allStyles: core.DartList<_CompactStyle>;
}
export declare class _CompactStyle extends _CompactStyleBase {
    constructor(_namedArguments?: {
        pattern?: string;
        requiredDigits?: number;
        divisor?: number;
        expectedDigits?: number;
        prefix?: string;
        suffix?: string;
    });
    _CompactStyle(_namedArguments?: {
        pattern?: string;
        requiredDigits?: number;
        divisor?: number;
        expectedDigits?: number;
        prefix?: string;
        suffix?: string;
    }): void;
    pattern: string;
    requiredDigits: number;
    divisor: number;
    expectedDigits: number;
    prefix: string;
    suffix: string;
    readonly totalDigits: number;
    readonly isFallback: boolean;
    readonly printsAsIs: boolean;
    styleForSign(number: any): _CompactStyle;
    readonly allStyles: core.DartList<this>;
}
export declare class _CompactNumberFormat extends NumberFormat {
    static _forDecimal(symbols: lib6.NumberSymbols): string;
    _patterns: core.DartMap<number, string>;
    _styles: core.DartList<_CompactStyleBase>;
    constructor(_namedArguments?: {
        locale?: string;
        formatType?: _CompactFormatType;
        name?: string;
        currencySymbol?: string;
        getPattern?: (symbols: lib6.NumberSymbols) => string;
        computeCurrencySymbol?: (NumberFormat: any) => string;
        decimalDigits?: number;
        isForCurrency?: boolean;
    });
    _CompactNumberFormat(_namedArguments?: {
        locale?: string;
        formatType?: _CompactFormatType;
        name?: string;
        currencySymbol?: string;
        getPattern?: (symbols: lib6.NumberSymbols) => string;
        computeCurrencySymbol?: (NumberFormat: any) => string;
        decimalDigits?: number;
        isForCurrency?: boolean;
    }): void;
    _regex: any;
    _justZeros: any;
    _hasNonZeroContent(pattern: string): boolean;
    _createStyle(pattern: string, impliedDigits: number): _CompactStyle;
    _style: _CompactStyle;
    format(number: any): string;
    _fractionDigitsAfter(remainingSignificantDigits: number): number;
    _divide(numerator: any, denominator: number): number;
    _styleFor(number: any): _CompactStyle;
    readonly _stylesForSearching: core.DartIterable<_CompactStyle>;
    parse(text: string): number;
    _tryParsing(text: string): number;
    readonly compactSymbols: lib6.CompactNumberSymbols;
}
export declare class _DateFormatLiteralField extends _DateFormatField {
    constructor(pattern: any, parent: any);
    _DateFormatLiteralField(pattern: any, parent: any): void;
    parse(input: _Stream, dateFields: _DateBuilder): void;
    parseLoose(input: _Stream, dateFields: _DateBuilder): void;
}
export declare class _DateFormatQuotedField extends _DateFormatField {
    _fullPattern: string;
    fullPattern(): string;
    constructor(pattern: any, parent: any);
    _DateFormatQuotedField(pattern: any, parent: any): void;
    parse(input: _Stream, dateFields: _DateBuilder): void;
    parseLoose(input: _Stream, dateFields: _DateBuilder): void;
    private static __$_twoEscapedQuotes;
    static _twoEscapedQuotes: any;
    static _patchQuotes(pattern: string): string;
}
export declare class _DateFormatPatternField extends _DateFormatField {
    constructor(pattern: any, parent: any);
    _DateFormatPatternField(pattern: any, parent: any): void;
    format(date: core.DartDateTime): string;
    parse(input: _Stream, dateFields: _DateBuilder): void;
    parseLoose(input: _Stream, dateFields: _DateBuilder): void;
    _forDate: boolean;
    readonly forDate: boolean;
    parseField(input: _Stream, builder: _DateBuilder): void;
    formatField(date: core.DartDateTime): string;
    readonly symbols: lib10.DateSymbols;
    formatEra(date: core.DartDateTime): any;
    formatYear(date: core.DartDateTime): string;
    handleNumericField(input: _Stream, setter: Function, offset?: number): void;
    parseEnumeratedString(input: _Stream, possibilities: core.DartList<any>): number;
    formatMonth(date: core.DartDateTime): string;
    parseMonth(input: any, dateFields: any): void;
    format24Hours(date: core.DartDateTime): string;
    formatFractionalSeconds(date: core.DartDateTime): string;
    formatAmPm(date: core.DartDateTime): string;
    parseAmPm(input: any, dateFields: any): void;
    format1To12Hours(date: core.DartDateTime): string;
    parse1To12Hours(input: _Stream, dateFields: _DateBuilder): void;
    format0To11Hours(date: core.DartDateTime): string;
    format0To23Hours(date: core.DartDateTime): string;
    formatStandaloneDay(date: core.DartDateTime): string;
    parseStandaloneDay(input: _Stream): void;
    formatStandaloneMonth(date: core.DartDateTime): string;
    parseStandaloneMonth(input: any, dateFields: any): void;
    formatQuarter(date: core.DartDateTime): string;
    formatDayOfMonth(date: core.DartDateTime): string;
    formatDayOfYear(date: core.DartDateTime): string;
    formatDayOfWeek(date: core.DartDateTime): string;
    parseDayOfWeek(input: _Stream): void;
    parseEra(input: _Stream): void;
    formatMinutes(date: core.DartDateTime): string;
    formatSeconds(date: core.DartDateTime): string;
    formatTimeZoneId(date: core.DartDateTime): string;
    formatTimeZone(date: core.DartDateTime): string;
    formatTimeZoneRFC(date: core.DartDateTime): string;
    padTo(width: number, toBePrinted: any): string;
}
export declare class _LoosePatternField extends _DateFormatPatternField {
    constructor(pattern: string, parent: any);
    _LoosePatternField(pattern: string, parent: any): void;
    parseEnumeratedString(input: _Stream, possibilities: core.DartList<any>): number;
    parseMonth(input: any, dateFields: any): void;
    parseStandaloneDay(input: any): void;
    parseStandaloneMonth(input: any, dateFields: any): void;
    parseDayOfWeek(input: _Stream): void;
}
export declare class properties {
}
